# 四、编程语言通识与JavaScript语言设计

<a name="A3QYH"></a>
## 语言按语法分类
![](https://cdn.nlark.com/yuque/0/2020/svg/1254064/1587491731097-8b4d79a4-64b8-4d99-a50a-8213faccfd91.svg)<a name="NCsKN"></a>
### 乔姆斯基谱系
> 乔姆斯基谱系：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的，它包括四个层次：

- 0- 型文法（无限制文法或短语结构文法）包括所有的文法。
- 1- 型文法（上下文相关文法）生成上下文相关语言。
- 2- 型文法（上下文无关文法）生成上下文无关语言。
- 3- 型文法（正规文法）生成正则语言。



<a name="55JkO"></a>
#### 主要特点
| 文法 | 语言 | 自动机 | 产生式规则 | 通过产生式理解 |
| :--- | :--- | :--- | :--- | :--- |
| 0-型 | 递归可枚举语言 | 图灵机 | ?::=? | 等号两侧可以有多个产生式，无限制 |
| 1-型 | 上下文相关语言 | 线性有界非确定图灵机 | ?<A>?::=?<B>? | 等号两侧可以有多个产生式，但是只能改变中间的 |
| 2-型 | 上下文无关语言 | 非确定下推自动机 | <A>::=? | 等号左边只能有一个字符 |
| 3-型 | 正规语言 | 有限状态自动机 | <A>::=<A>?<br /><A>::=?<A> ❌ | 只能有左递归，A如果出现在等号的左边，那么右边就只能出现在每个或的最开头 |



<a name="Xb5u4"></a>
## 产生式（BNF）
在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句。

> 如果某种条件满足，就执行某种动作

<br />
<a name="1tKr0"></a>
### 巴科斯范式
> 巴科斯范式是一种用形式化符号精确描述程序设计语言的语法的一种形式系统。又称巴科斯－诺尔形式，简称BNF范式。实际上，**BNF范式等价于乔姆斯基的2型文法**。它是一种典型的元语言，可以严格地表示语法规则，且描述的文法是上下文无关文法。



<a name="TxmAz"></a>
#### BNF表示语法规则的方式为：

- 非终结符用尖括号< >括起
- 每条规则的左部是一个非终结符，右部是由非终结符和终结符组成的一个符号串，中间一般以“：：=”分开
- 具有相同左部的规则可以共用一个左部，各右部之间以直竖“|”隔开，相当于or；



<a name="GeuiN"></a>
#### BNF中常用的元字符及其表示的意义：

- 在双引号中的字"word"代表着这些字符本身。而double_quote用来代表双引号。
- 在双引号外的字（有可能有下划线）代表着语法部分。
- 尖括号 < > 内包含的为必选项。
- 方括号 [ ] 内包含的为可选项。
- 大括号 { } 内包含的为可重复0至无数次的项。
- 圆括号 ( ) 内包含的所有项为一组，用来控制表达式的优先级；
- 竖线 | 表示在其左右两边任选一项，相当于"OR"的意思。
- ::= 是“被定义为”的意思。
- A* 表示元素A可以有0次或多次出现。
- A+ 表示元素A可以有1次或多次出现。



<a name="5uAXX"></a>
#### 终结符与非终结符：
终结符： 不能单独出现在推导式左边的符号，也就是说终结符不能再继续通过生成式向下进行推导。

非终结符： 不是终结符的都是非终结符。非终结符可理解为一个可拆分元素，而终结符是不可拆分的最小元素。

<a name="cH3jJ"></a>
### 其它产生式
<a name="soIu3"></a>
#### EBNF<br />
<a name="vy8xN"></a>
#### ABNF
<a name="2DqXY"></a>
#### Customized


<a name="z1rz0"></a>
## 图灵完备型
在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）按照一定的顺序可以计算出结果，被称为图灵完备（turing complete）。<br />

> 一个有图灵完备指令集的设备被定义为通用计算机。如果是图灵完备的，它（计算机设备）有能力执行条件跳转（if、while、goto语句）以及改变内存数据。 图灵完备意味着你的语言可以做到能够用图灵机能做到的所有事情，可以解决所有的可计算问题。



- 命令式——图灵机
  - goto
  - if和while
- 声明式——lambda
  - 递归



<a name="lVJy8"></a>
## 动态与静态语言
<a name="m0SWd"></a>
### 动态语言
> 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，该语言会在你第一次赋值给变量时，在内部记录数据类型。 

**<br />**动态：**

- 在用户的设备/在线服务器上
- 产品实际运行时
- Runtime（运行时）


<br />**例如：**PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

<a name="O8DOU"></a>
### 静态语言
> 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 

**<br />**静态：**

- 在程序员的设备上
- 产品开发时
- Compiletime（编译时）

**<br />**例如：**C++、Java、Delphi、C#等。

<a name="5GXPF"></a>
### 两者区别
<a name="M7jlU"></a>
#### 特性
**强类型语言**是一旦变量的类型被确定，就不能转化的语言。<br />**弱类型语言**则反之，一个变量的类型是由其应用上下文确定的。<br />

<a name="Ap0nW"></a>
#### 静态语言的优势

- 由于类型的强制声明，使得IDE有很强的代码感知能力，故，在实现复杂的业务逻辑、开发大型商业系统、以及那些生命周期很长的应用中，依托IDE对系统的开发很有保障；
- 由于静态语言相对比较封闭，使得第三方开发包对代码的侵害性可以降到最低；



<a name="DpjNe"></a>
#### 动态语言的优势

- 思维不受束缚，可以任意发挥，把更多的精力放在产品本身上；
- 集中思考业务逻辑实现，思考过程即实现过程；



<a name="br4Z7"></a>
## 类型系统
<a name="v7okp"></a>
### 动态类型系统与静态类型系统
<a name="fO733"></a>
### 强类型与弱类型
强类型： 无隐式转换<br />弱类型： 有隐式转换

- String + Number
- String == Boolean
<a name="8tdDz"></a>
### 复合类型

- 结构体
- 函数签名
<a name="TNF2D"></a>
### 子类型

- 逆变/协变



<a name="LH9ah"></a>
## 一般命令式编程语言
![image.png](https://cdn.nlark.com/yuque/0/2020/png/1254064/1587491054442-f578bd00-b27d-4b96-830b-c0ad94bf63c7.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=899&size=133609&status=done&style=none&width=746)<br />

<a name="HXXq8"></a>
## 拓展阅读

- 协变与逆变：[ https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html](https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html)
- Yacc 与 Lex 快速入门：[ https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html](https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html)
- 关于元编程：[ https://www.zhihu.com/question/23856985](https://www.zhihu.com/question/23856985)
- 编程语言的自举：[ https://www.cnblogs.com/lidyan/p/6727184.html](https://www.cnblogs.com/lidyan/p/6727184.html)
- 推荐阅读：ECMA-262 Grammar Summary 部分
